## Comparative analysis: structs (C) vs classes (C++) and values vs pointers

This project implements, runs, and visualizes benchmarks comparing:

- Performance: values (val) vs pointers (ptr)
- Structural efficiency: `struct` in C vs `class` in C++

It records time and memory metrics for a set of query functions over collections of people, implemented equivalently in C and C++.

### Recorded metrics
- Wall_ms: wall-clock time (CLOCK_MONOTONIC)
- CPU_ms: process CPU time (CLOCK_PROCESS_CPUTIME_ID)
- HeapKB_Delta: heap delta in KB (mallinfo2 → bytes in use)
- RSSKB_Delta: resident set size delta in KB (VmRSS from `/proc/self/status`)


## Requirements
- Linux with `/proc/` (memory measurement via VmRSS)
- `make`, `gcc`, `g++`
- (Optional) `valgrind` tools: `memcheck`, `massif`, `dhat`
- Python 3.8+ with plotting libraries: `pandas`, `matplotlib`, `seaborn`

Install Python deps (virtualenv recommended):
```bash
python3 -m venv .venv
. .venv/bin/activate
pip install pandas matplotlib seaborn
```


## Project layout
```
first_assessment/
  class_cpp/
    include/            # C++ headers (persona, queries_class, generador, shared benchmark)
    src/                # C++ sources (queries, generator, persona, single harness)
    main.cpp            # runs all C++ benchmarks in a single process
    makefile            # builds main binary and `single` harness

  struct_c/
    include/            # C headers (person, queries, generator, benchmark)
    src/                # C sources (queries, generator, person, benchmark, single harness)
    main.c              # runs all C benchmarks in a single process
    makefile            # builds main binary and `single` harness

  benchmarks/           # resultados al ejecutar scripts (CSV, logs, gráficos)
    isolated/           # CSV generated in isolated mode (one process per function/mode/N)
    plots/              # charts generated by charts.py

  run_benchmakrs.sh     # fast global run per language
  run_isolated.sh       # isolated run per function×mode×N (more rigorous)
  run_valgrind.sh       # Valgrind analysis (memcheck/massif/dhat)
  charts.py             # produces charts from existing CSVs
```


## Build
Build both projects (C and C++):
```bash
make -C struct_c
make -C class_cpp
```
Each makefile also exposes a `single` target (harness) used in isolated mode:
```bash
make -C struct_c single
make -C class_cpp single
```


## Bash scripts and differences

### 1) run_benchmakrs.sh (global run)
- Builds both projects.
- Runs `struct_c/main` and `class_cpp/main` (all functions and sizes in a single process per language).
- Produces CSVs:
  - `benchmarks/results_struct.csv` (C)
  - `benchmarks/results_class.csv` (C++)
  - `benchmarks/results_summary.csv` (shared header; concatenation of both)

Pros: fast, end-to-end. Note: since everything runs in one process per language, memory deltas may be influenced by previous calls.

### 2) run_isolated.sh (isolated per function×mode×N)
- Builds harness per language (`struct_c/single`, `class_cpp/single`).
- For each size and function, runs both modes (ptr/val) in separate processes.
- Produces CSVs:
  - `benchmarks/isolated/results_struct.csv`
  - `benchmarks/isolated/results_class.csv`
  - `benchmarks/isolated/results_summary.csv` (shared header; concatenation)

Pros: full isolation per measurement ⇒ cleaner time/memory comparisons across ptr vs val and C vs C++.

### 3) run_valgrind.sh (sanity checks and memory profiles)
- Cleans and rebuilds with `-g`.
- Runs:
  - Memcheck (leaks and errors): logs at `benchmarks/valgrind/memcheck_{struct,class}.log`
  - Massif (heap history profile): `massif_*.out` and `massif_*.txt`
  - DHAT (granular heap objects analysis): `dhat_*.out`

Warning: Valgrind typically runs 3–20× slower. Reduce `N` if needed.


## CSV format
All generated CSVs share the following header:
```
Implementation,Function,N,Wall_ms,CPU_ms,HeapKB_Delta,RSSKB_Delta
```
Example rows (isolated mode):
```
C (ptr),findOldest,100000,1.234,1.200,0,0
C (val),findOldest,100000,2.345,2.300,0,0
C++ (ptr),findOldest,100000,0.987,0.980,0,0
C++ (val),findOldest,100000,1.456,1.450,0,0
```
Naming notes:
- C++ uses `listTaxGroup_*` / `countTaxGroup_*`, while C uses `listByGroup_*` / `countByGroup_*`. Charts normalize these aliases for comparison.


## Running benchmarks

### Global run (per language)
```bash
./run_benchmakrs.sh
```
Relevant output:
- CSV: `benchmarks/results_{struct,class,summary}.csv`
- C logs: `results_ptr.log`, `results_val.log`, `results_combined.log` (repo root)

### Isolated run (per function×mode×N)
```bash
./run_isolated.sh
```
Relevant output:
- CSV: `benchmarks/isolated/results_{struct,class,summary}.csv`


## Charts (Python)
Generate visualizations (with venv active or deps installed):
```bash
python3 charts.py
```
Output:
- `benchmarks/plots/` contains:
  - For each base function and size N: bars comparing `C/C++ × ptr/val` per metric (Wall, CPU, HeapΔ, RSSΔ)
  - `val/ptr` speedups per language for all metrics

Notes:
- The script skips zero/invalid points to avoid noisy charts.
- To limit the scope, remove or move undesired CSVs before running.


## Valgrind (optional)
```bash
./run_valgrind.sh
```
Results:
- Memcheck: `benchmarks/valgrind/memcheck_{struct,class}.log` ⇒ check "ERROR SUMMARY" and "LEAK SUMMARY".
- Massif: `benchmarks/valgrind/massif_{struct,class}.txt` ⇒ heap peak and allocation trees.
- DHAT: `benchmarks/valgrind/dhat_{struct,class}.out` ⇒ granular analysis (view with `dhat/dh_view.html`).

Per-function/mode profiles (using harness):
```bash
valgrind --tool=massif ./struct_c/single --func=findOldest --mode=ptr --n=100000
valgrind --tool=massif ./class_cpp/single  --func=findOldest --mode=val --n=100000
```


## Methodological notes
- Time is measured strictly around the function call (no extra I/O).
- Memory is recorded as pre/post deltas:
  - HeapKB_Delta: true heap usage visible to the allocator (mallinfo2)
  - RSSKB_Delta: process resident footprint (may be influenced by OS/allocator policies)
- The isolated run ensures a clean baseline per function×mode×N ⇒ ideal for ptr vs val and C vs C++ comparisons.


## Common issues
- Valgrind is too slow: reduce sizes in the scripts or use the harness with smaller `N`.
- Missing Python libs: create/activate a venv, then `pip install pandas matplotlib seaborn`.
- Empty charts: the script skips 0/NaN values; ensure non-zero data exists for that function and N.


## License & credits
Academic project to assess memory access techniques and data structures in C/C++.


